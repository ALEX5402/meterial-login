package bruhcollective.itaysonlab.jetisteam.rpc

import androidx.collection.LruCache
import bruhcollective.itaysonlab.jetisteam.controllers.SteamWebApiTokenController
import com.squareup.wire.Message
import com.squareup.wire.ProtoAdapter
import com.squareup.wire.WireRpc
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import okhttp3.OkHttpClient
import okio.use
import javax.inject.Inject
import javax.inject.Named
import javax.inject.Singleton

@Singleton
class SteamRpcProcessor @Inject constructor(
    @Named("steamOkhttp") private val okHttpClient: OkHttpClient,
    private val neutralOkHttpClient: OkHttpClient,
    private val webApiTokenController: SteamWebApiTokenController
) {
    private val adapterCache = LruCache<String, ProtoAdapter<*>>(10)

    suspend fun execute(
        annotation: WireRpc,
        args: Array<*>
    ): Any = withContext(Dispatchers.IO) {
        // 1. Collect data for making a request
        val request = args.first() as Message<*, *> // safe for autogenerated code
        val responseAdapter = findAdapterBy(annotation.responseAdapter)
        val decomposedPath = ServiceAndMethod(annotation.path.split("/").drop(1)) // "/Service/Method"

        // 2. Process the input data for workaround apply
        val requestUrl = SteamRpcWorkarounds.formatUrl(decomposedPath)
        val shouldUsePost = SteamRpcWorkarounds.shouldUsePostFor(annotation.path)
        val shouldUseWebapiToken = SteamRpcWorkarounds.shouldUseWebApiController(annotation.path)
        val requestCall = SteamRpcWorkarounds.createRequest(requestUrl, request, shouldUsePost)

        // 3. Request a WebAPI token if this method is "special". If not, just call OkHttp as usual
        return@withContext if (shouldUseWebapiToken != null) {
            val webapiToken = webApiTokenController.requestWebApiTokenFor(realm = shouldUseWebapiToken)

            val modifiedRequestCall = requestCall.newBuilder().apply {
                url(requestCall.url.newBuilder().addQueryParameter("access_token", webapiToken).build())
            }.build()

            neutralOkHttpClient.newCall(modifiedRequestCall)
        } else {
            okHttpClient.newCall(requestCall)
        }.execute().use { response ->
            responseAdapter.decode(response.body.source())!!
        }
    }

    // *pkg*#ADAPTER
    private fun findAdapterBy(pkg: String): ProtoAdapter<*> {
        val cachedAdapter = adapterCache.get(pkg)

        return if (cachedAdapter == null) {
            val pkgAndField = PackageAndField(pkg.split("#"))
            val clazz = Class.forName(pkgAndField.packagePath).getDeclaredField(pkgAndField.fieldName).get(null) as ProtoAdapter<*> // companion object + JvmField
            adapterCache.put(pkg, clazz)
            clazz
        } else {
            cachedAdapter
        }
    }

    @JvmInline
    value class PackageAndField(
        private val packed: List<String>
    ) {
        val packagePath get() = packed[0]
        val fieldName get() = packed[1]
    }

    @JvmInline
    value class ServiceAndMethod(
        private val packed: List<String>
    ) {
        val service get() = packed[0]
        val method get() = packed[1]
    }
}